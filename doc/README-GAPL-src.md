# Cache source code notes

Reading notes made by M Young from December 2018 through 
August 2019 (so far) as
I navigate the source code to understand how things fit together. 
In particular I am trying to understand how GAPL is compiled and 
interpreted, in preparation for adding support for another 
surface language. 

## Contents 
* [Summary of control](#summary-flow)
* [Client side flow](#client-side-flow) 
* [Server side flow](#server-side-flow)
* [The automaton structure](#automaton-rep)
* [The automaton byte code structure](#byte-code-rep)
* [The automaton instruction set](#instructions)
* [Additional notes](#additional)

<a id="summary-flow"> </a>

##Summary of flow 

The main program in `registercallback.c` is invoked with 
the literal text of a GAPL automaton on the command line. 
The requires replacing newlines with carriage returns, 
using `lftocr`.  

`registercallback` creates an SQL command and transmits it 
to the cache server, which should already be listening on a 
known port. 

On the server side, `hwdb.c` receives the command and recognizes it as a registration request.  `hwdb.c` strips
off outer quotes, re-inserts line feeds, and calls 
`au_create` in `automaton.c`. 

`au_create` constructs the structure.  It invokes 
`a_parse`, the bison-generated parser from `agram.y`, 
and copies elements of the parser-generated IR into 
fields of the automaton.  `a_parse` (`agram.y`) constructs 
the IR with calls to functions in `code.c`. 

The resulting automaton structure is opaque (`automaton.h` 
publishes only the pointer type, with the structure fully 
defined internally in `automaton.c`).  It includes a 
table mapping variable names to offsets in the run-time 
structure and two sequences of byte code instructions, 
the initialization section and the behavior section.  
The byte code format is a sequence of function pointers, 
but immediate operands of some operations (notably 
`varpush` and `constpush`) are represented instead as 
data records; the operations that use them (e.g. `varpush`) 
are responsible for advancing the program counter past them.  


<a id="server-side-flow">&nbsp;</a>


<a id="client-side-flow">&nbsp;</a>

## How the parser is invoked: Client side 

`registercallback.c` is the preferred way to install an automaton. Per Joe (July 2019): 
  >
  >The registercallback application enables you to register an 
  >automaton and to then receive all of the events generated by 
  >the automaton.  The synopsis is

``` 
./registercallback [-h host] [-p port] [-s service] [-t minutes] –a automaton
```

>The “automaton” argument above is the actual source code for 
>the automaton – it needs to have all linefeeds converted to 
>carriage returns in order to be acceptable to the shell. 
>The program lftocr does this conversion, printing the 
>converted text on standard output; the code in the cache 
>converts the carriage returns back to linefeeds before invoking
> the compiler.  If foo.gapl is the automaton source file, the
>  registercallback invocation looks like this
> 
```
./registercallback ... –a “`./lftocr foo.gapl`”
```
 
>alternatively, for bash
 
```
./registercallback ... –a “$(./lftocr foo.gapl)”
```



The transmitted query appears to be 

```
SQL:register \"%s\" %s %hu %s",automata,lhost,lport,MY_SERVICE_NAME`
```



### Other client-side connections 

Initially I believed `cacheclient.c` and `testclient.c` were 
the preferred ways to register an automaton, and that 
`registercallback.c` was a small test program.  This was reversed.  However, there is some potentially useful code in 
them that could be migrated into the preferred path. 

* cacheconnect.c has install_file_automata, which reads the automaton
source file and calls `install_automata`, defined as
`install_automata(char* automata, AutomataHandler_t ahandle)`.

* `testclient.c`  shares 
some functionality but notably has a bug in reading the automaton source code from disk.  (Easy to repair as now 
noted in source code, but the bug was a clue that 
`testclient.c` was not the main client code.) 

* testclient.c calls install_file_automata with command RF.
   First argument is file path. Second argument is a handler,
   `dumpToStdout`, which calls `print_cache_response(r, stdout)`,
   in `cacheconnect.h`:
   `void print_cache_response(CacheResponse r, FILE* fd)`.

A cache response is

```
/* Response Data */
struct cache_response_t {
    int retcode;
    char* message;
    int ncols;
    int nrows;

    char** headers;
    char** data;
};
```


`Q_Decl` and `Q_Arg` in srpc.h are defined as

```
#define Q_Decl(QUERY,SIZE) char QUERY[SIZE]; \
                           const struct qdecl QUERY ## _struct = {SIZE,QUERY}
#define Q_Arg(QUERY) (&QUERY ## _struct)
```


## How the parser is Invoked: Server Side 

On the server side, the SQL parser `gram.y` recognizes a 
*register* command and marks it `SQL_TYPE_REGISTER`. 
I have not fully traced the calling sequence, but the 
`SQL_TYPE_REGISTER` tag is recognized in `hwdb.c`, viz

```C
    case SQL_TYPE_REGISTER: {
        int v;
        if (isreadonly || !(v = hwdb_register(&stmt.sql.regist))) {
            results = rtab_new_msg(RTAB_MSG_REGISTER_FAILED, NULL);
        } else {
            // Happy path:  hwdb_register succeeded
            static char buf[20];
            sprintf(buf, "%d", v);
            results = rtab_new_msg(RTAB_MSG_SUCCESS, buf);
        }
        break;
```

Note the happy path is:  The cache is not readonly, and `hwdb_register` 
returns a non-zero automaton identifier indicating success.  In this case we take the `else`
and emit a success message. `v` holds the automaton identifier. 

`hwdb_register` strips the quotes off a copy of the buffer and gives it 
to `au_create` in `automaton.c`. 

 

* The SQL parser in `parser.c` recognizes the query and translates it to `SQL_TYPE_REGISTER`.
  This is one of the query cases in hwdb.c, which does:

   ```
       case SQL_TYPE_REGISTER: {
           int v;
           if (isreadonly || !(v = hwdb_register(&stmt.sql.regist))) {
               results = rtab_new_msg(RTAB_MSG_REGISTER_FAILED, NULL);
           } else {
               static char buf[20];
               sprintf(buf, "%d", v);
               results = rtab_new_msg(RTAB_MSG_SUCCESS, buf);
           }
           break;
    ```

  Then `hwdb_register` does

  ```
      /* compile automaton */
      /* automaton has leading and trailing quotes */
      strcpy(buf, regist->automaton+1);
      /* convert '\r' back into '\n' */
      for (p = buf; *p != '\0'; p++)
          if (*p == '\r')
              *p = '\n';
      /* remove trailing quote */
      p = strrchr(buf, '\"');
      *p = '\0';
      debugf("automaton: %s\n", buf);
      au = au_create(buf, rpc, ebuf);
      if (! au) {
          errorf("Error creating automaton - %s\n", ebuf);
          rpc_disconnect(rpc);
          return 0;
      }
    ```


* au_create in automaton.c is called by hwdb.c:

    `Automaton *au_create(char *program, RpcConnection rpc, char *ebuf)`

* `au_create` in `automaton.c` calls `a_parse`, which is the symbol `yyparse`
becomes in `agram.y`.  (`au_create` could therefore be a good
place to put the dumping code.)

* Program code can be dumped by function in code.c:

    ```
    void dumpCompilationResults(unsigned long id, ArrayList *v, ArrayList *i2v,
                                     InstructionEntry *init, int initSize,
                                     InstructionEntry *behav, int behavSize) {
    ```

    It appears that au_create has all the arguments needed for dumpCompilationResults.



* GAPL parser:  agram.y --- includes the lexer (function a_lex). 
    Highly table-driven; includes table of keywords for the lexer. 
    
* GAPL code generation:  semantic routines in agram.y call function 
   ```code``` in code.c to produce InstructionEntry objects.
   This appears to be by side-effect: Although code() returns a pointer
   to an InstructionEntry, this is (always?) not used in the 
   semantic routines.
   
   Signature of the `code` function: 
   
   ```C
   InstructionEntry *code(int ifInst, Inst f, DataStackEntry *d, char *what,
                          int lineno) {
   ```
  
  example for left-hand side of `VAR = expression`:
  
  ```C
  code(TRUE, varpush, NULL, "varpush", lineno);
  ```
  
  `TRUE` says "this is an instruction, not data"; contrast with 
  the immediate operand coded as 
  
  ```C
  initDSE(&dse, dINTEGER, 0);
  (void) hm_get(vars2index, $1, &value);
  dse.value.int_v = (long long)value;
  code(FALSE, STOP, &dse, "variable name", lineno);
  ```
  
  Second operand f (`varpush` in first example) is the address of an instruction 
  function in code.c.  `STOP` appears to be a placeholder for data 
  words.  The data stack entry (dse) is NULL for an instruction, 
  and the value (which could be index of a variable) for a data word. 
  `what` is debugging information, usually the name of the operation, 
  and `lineno` is likewise debugging information (which is currently 
  not used). 
  
* globals in compilation

    Some information is passed between parser and other components 
    through a set of global variables in `a_globals.h`: 
    
    ```C
    /* declared in agram.y */
    extern ArrayList *variables;
    extern ArrayList *index2vars;
    extern HashMap *topics;
    extern HashMap *builtins;
    extern char *progname;
    /* declared in code.c */
    extern InstructionEntry *progp, *startp, *initialization, *behavior;
    extern int initSize, behavSize;
    extern int iflog;
    /* declared in automaton.c */
    extern pthread_key_t jmpbuf_key;
    extern pthread_key_t execerr_key;
    ```
   Many `hm_put` operations in the parser refer to these 
   hashmaps.   This is how an automaton's variable list and 
   subscriptions are communicated to the automaton builder.   
   
* The automaton structure variables are divided into run-time 
  fields and fields constructed in compilation.  The run-time 
  fields are in the first part of the struct (in `automaton.c`):

   ```C
    struct automaton {
        short must_exit;
        short has_exited;
        unsigned long id;
        pthread_mutex_t lock;
        pthread_cond_t cond;
        LinkedList *events;
    ```
  
   The rest of the struct is what the parser builds, 
   with the same names as they have in `a_globals.h`
   except as noted below: 
   
   ```C
        HashMap *topics;          /* declared in agram.y */
        ArrayList *variables;     /* declared in agram.y */  
        ArrayList *index2vars;    /* declared in agram.y */
        InstructionEntry *init;   /* initialization in code.c */
        InstructionEntry *behav;  /* behavior in code.c */
        RpcConnection rpc;        /* not in a_globals.h */ 
    };
   ```
  
  
   
* GAPL instruction code
    Entries are tagged as being either instructions or data. 
    This being a stack machine, I assume being data means it 
    should be pushed onto the stack.  Instructions codes 
    appear to be function pointers (so this is a variety of 
    threaded code). 
    
    While it is a stack machine, the instruction sequence 
    includes immediate values (data) that are not instructions
    per se.  The sequence for loading a value is 
    ```asm
    varpush   (function pointer)
    DATA  i   (index of variable)
    eval      (function pointer)
  ```
  Note the `varpush` is explicit and the function expects to find 
  the variable index in the next instruction slot.  This makes the 
  instruction dispatch loop simpler, at the cost of requiring the 
  `varpush` routine increment the program counter to eat its argument, 
  viz, 
  ```C
  void varpush(MachineContext *mc) {
      push(mc->stack, mc->pc->u.immediate);
      mc->pc++;
  }
  ``` 
  The execution of one instruction is 
  ```C
  (*((mc->pc++)->u.op))(mc);
  ```
  where mc->pc is the program counter.  Apparently
  the order of evaluation must be 
    * tmp = mc->pc
    * increment pc
    * func = tmp -> u.op
    * func(mc)
  
  so that within varpush (and similarly constpush) the program counter
  has already been incremented to point at the immediate operand.
  Besides simplifying the execution loop, this probably makes it a 
  little faster. 


* GAPL instruction functions:  each virtual machine instruction
     is a function pointer, except for immediate operands which 
     are DATA entries.  Note the convention above (varpush and 
     constpush increment pc after consuming their operands) allows 
     the main dispatch loop to simply call each instruction; the 
     instructions are responsible for skipping over the data entries. 
     
Threaded code, with no table from opcodes
to instructions, but rather function pointers directly in the instruction stream. The execution of an instruction is 
```
(*((mc->pc++)->u.op))(mc)
```

* mc is the machine context (state of virtual machine)
* pc is the program counter, which is incremented after execution
of the instruction.  (A little confused about this access ... 
I think pc is an entry in an array, so the increment moves us 
to the next instruction.)  
* u.op must be a member of the 'pc' structure that points
to the function that executes the code.  Does the structure 
contain anything else? Guess:  Since we are not testing for 
data vs code here, each instruction must have a slot for an 
operand, and 'push' must be a possible instruction. 
Yes, the instruction is 
```void constpush(MachineContext *mc);```.  There is likewise 
a ```varpush``` function. 

* The instruction functions are declared in code.h, just after ```execute```. 


First argument to ```code``` (called from parser) is a boolean with true indicating code
(type FUNC) and false indicating data (type DATA): 
```
        if (ifInst) {
            progp->type = FUNC;
            progp->u.op = f;
        } else {
            progp->type = DATA;
            progp->u.immediate = *d;
        }
```

There are richer type tags in the instructions.  
An instructionEntry is: 
```
struct instructionEntry {
    int type;
    union {
        Inst op;
        DataStackEntry immediate;
        int offset;			/* offset from current PC */
    } u;
    char *label;
    int lineno;				/* corresponding source line no */
};
```

The type entries are defined in `dataStackEntry.h`.  They are 
dNULL , dBOOLEAN, dINTEGER, dDOUBLE, dTSTAMP, dSTRING, dEVENT, 
dMAP, dIDENT, dTIDENT, dWINDOW, dITERATOR, dSEQUENCE, dPTABLE.  

Inst is the function pointer: 
```
typedef void (*Inst)(MachineContext *mc);  /* actual machine instruction */
```


Instruction set (all stack-based, so e.g., plus is push(pop() + pop()): 

|Instruction  |  Action                                 |
|-------------|-----------------------------------------|
|constpush          | Push constant value                     |
| varpush	           | Push variable | 
| add	               | +
| subtract	       | -
| multiply       	   | *
| divide            	| / 
| modulo	| %
| negate	| -
| eval	|
| extract	|
| gt	| >
| ge	| >=
| lt	| <
| le	| <=
| eq	| ==
| ne	| !=
| and	| &&
| or	| ||
| not	| !
| function	|
| print	|
| assign	| =
| pluseq	| +=
| minuseq	| -=
| whilecode	|
| ifcode	|
| procedure	|
| newmap	|
| newwindow	|
| destroy	|
| bitOr	| |
| bitAnd	| &

Code generator often calls "InitDSE", which is a macro: 

```
#define initDSE(d,t,f) {(d)->type=(t); (d)->flags=(f); }
```

## Conditional branching

IF and WHILE work by back-patching relative offsets.  Considering the if/else, 
the basic structure is established when the keyword "IF" is parsed: 

```yacc
if:		  IF {
                    InstructionEntry *spc;
                    if (iflog)
                      fprintf(stderr, "Starting code generation for if\n");
                    spc = code(TRUE, ifcode, NULL, "ifcode", lineno);
                    code(TRUE, STOP, NULL, "thenpart", lineno);
                    code(TRUE, STOP, NULL, "elsepart", lineno);
                    code(TRUE, STOP, NULL, "nextstatement", lineno);
                    $$ = spc;
                  }
                ;
```

Each part of an `ifcode` or `whilecode` 
instruction is executed by function `execute`, which runs up to a `STOP` instruction: 

```C
void execute(MachineContext *mc, InstructionEntry *p) {
    mc->pc = p;
    while (mc->pc->u.op != STOP) {
        (*((mc->pc++)->u.op))(mc);
    }
}
```

The `STOP` instructions are provided by the `end` empty non-terminal that is included in 
the productions for if/then/else and while: 

```yacc
end:		  /* nothing */ { code(TRUE, STOP, NULL, "STOP", lineno); $$ = progp; } ;
```
It appears that the difference between `PNTR` with offset and `DATA` with immediate 
integer value is only for documentation and debugging. 

The (relative) offsets are patched in when the rest of the IF construct is 
recognized: 

```yacc
                | if condition begin body else begin body end {
                    ($1)[1].type = PNTR;
                    ($1)[1].u.offset = $3 - $1;
                    ($1)[2].type = PNTR;
                    ($1)[2].u.offset = $6 - $1;
                    ($1)[3].type = PNTR;
                    ($1)[3].u.offset = $8 - $1;
                  }
```

Note $1 is the instruction built by 'if'.  $3 - $1 is instructions 
forward to the 'begin'.  $6 - $1 is instructions forward to the 'else' part. 
$8 - $1 is instructions forward to the endif.   If there is no else, 
this becomes: 

```yacc
                | if condition begin body end {
                    ($1)[1].type = PNTR;
                    ($1)[1].u.offset = $3 - $1;
                    ($1)[2].type = PNTR;
                    ($1)[2].u.offset = 0;
                    ($1)[3].type = PNTR;
                    ($1)[3].u.offset = $5 - $1;
                  }
```

Question:  Why is the 'else' offset set to 0 rather than the endif? 

Answer:  The 0 is because it doesn't actually jump to thenpart or elsepart (it 
         doesn't set the pc to those addresses), but rather calls 'execute'
         on the corresponding address.  The 0 disables calling execute on an else partm 
         which is guarded by `else if (elsepart != base)` in the code below. 
         
The instruction is executed by `ifcode`: 

```C
void ifcode(MachineContext *mc) {
    DataStackEntry d;
    InstructionEntry *base = mc->pc - 1;
    InstructionEntry *thenpart = base + mc->pc->u.offset;
    InstructionEntry *elsepart = base + (mc->pc+1)->u.offset;
    InstructionEntry *nextStmt = base + (mc->pc+2)->u.offset;
    InstructionEntry *condition = mc->pc + 3;

    if (iflog) {
        logit("ifcode called\n", mc->au);
        fprintf(stderr, "   PC        address %p\n", mc->pc);
        fprintf(stderr, "   condition address %p\n", condition);
        fprintf(stderr, "   thenpart  address %p\n", thenpart);
        fprintf(stderr, "   elsepart  address %p\n", elsepart);
        fprintf(stderr, "   nextstmt  address %p\n", nextStmt);
        logit("=====> Dumping condition\n", mc->au);
        dumpProgram(condition);
        logit("=====> Dumping thenpart\n", mc->au);
        dumpProgram(thenpart);
        if(elsepart != base) {
            logit("=====> Dumping elsepart\n", mc->au);
            dumpProgram(elsepart);
        } else
            logit("=====> No elsepart to if\n", mc->au);
    }
    execute(mc, condition);
    d = pop(mc->stack);
    if (iflog)
        fprintf(stderr, "%08lx: condition is %d\n", au_id(mc->au), d.value.bool_v);
    if (d.value.bool_v)
        execute(mc, thenpart);
    else if (elsepart != base)
        execute(mc, elsepart);
    mc->pc = nextStmt;
}
```

Aside 1:  The `PNTR` instruction entries following  `ifcode` and `whilecode` are 
never executed, only accessed for the `offset` values, so in principle they could 
be replaced by `DATA` instructions with immediate integer values if `ifcode` and `whilecode`
were modified to access those integer values.  Not a recommended change, but something 
that could be varied if the  Cache were used as a model for building another interpreter. 

Aside 2:  While the `ifcode` and `whilecode` operations differ from the way conditional 
branching is implemented on hardware machines and even in other bytecode interpreters 
like JVM, it bears some resemblance to the structured 
control flow of web assembly (WASM).  Authors of WASM point out that the hierarchically 
structured control flow makes bytecode type verification linear time, while potentially 
unstructured branching makes it potentially cubic time. 

## Linkage between automaton.c, code.c, agram.y

`code.c` initializes two buffers for building instructions, 

```C
InstructionEntry *initialization = initbuf;
InstructionEntry *behavior = behavbuf;
```

These are published in `code.h`

```C
extern InstructionEntry *initialization, *behavior;
```

So the parser can place instructions there and `automaton.c`
can copy them into the automaton structure. 

Several structures are initialized in `a_init` within `agram.y`.  While
`automaton.c` constructs the actual automaton structure, it is largely 
copying structures built in `agram.y`. 

## How `publish` works

Code generation for the Cache has a set of operations that are 
implemented not directly as function pointers (with one parameter being 
machine context) but indirectly as execution of a procedure-calling 
instruction.  The known procedures can have multiple arguments.  They
are in a table in agram.y: 

```
static struct fpstruct procedures[] = {
    {"topOfHeap", 0, 0, 0},     /* void topOfHeap() */
    {"insert", 3, 3, 1},	/* void insert(map, ident, map.type) */
    {"remove", 2, 2, 2},	/* void remove(map, ident) */
    {"send", 1, MAX_ARGS, 3},   /* void send(arg, ...) */
    {"append", 2, MAX_ARGS, 4}, /* void append(window, window.dtype[, tstamp]) */
    /* if wtype == SECS, must provide tstamp */
    /* void append(sequence, basictype[, ...]) */
    {"publish", 2, MAX_ARGS, 5},/* void publish(topic, arg, ...) */
    {"frequent", 3, 3, 6}       /* void frequent(map, ident, int) */
};
```

`publish` is not a keyword, but rather is matched by the grammar rule
for a procedure call: 

```
| PROCEDURE '(' argumentlist ')' ';' {
                    if (iflog)
                      fprintf(stderr, "%s called, #args = %lld\n", $1, $3);
                    code(TRUE, procedure, NULL, "procedure", lineno);
                    initDSE(&dse, dSTRING, 0);
                    dse.value.str_v = $1;
                    code(FALSE, STOP, &dse, "procname", lineno);
                    initDSE(&dse, dINTEGER, 0);
                    dse.value.int_v = $3;
                    code(FALSE, STOP, &dse, "nargs", lineno);
                  }
```

In `code.c`, the `procedure` function has a specific case for the 
`publish` operation: 

```
    case 5: {		/* void publish(topic, arg, ...) [max 20 args] */
        publishevent(mc, narg.value.int_v, args);
        break;
    }
```

`mc` is the machine context provided to each threaded action (called 
by the interpreter through the sequence of function pointers).  Additional 
information is extracted from the machine context: 

```
    DataStackEntry name = mc->pc->u.immediate;
    DataStackEntry narg = (mc->pc+1)->u.immediate;
    DataStackEntry args[MAX_ARGS];
    int i;
    unsigned int nargs;
    struct fpargs *range;

    nargs = narg.value.int_v;
```

The arguments to publish go on the `args` stack, after extracting them 
from the data stack maintained in the machine context: 

```
    for (i = narg.value.int_v -1; i >= 0; i--)
        args[i] = pop(mc->stack);
```

`publishevent` transforms the channel name and arguments into an SQL 
query, which is sent to the database part of the system. 

```
static void publishevent(MachineContext *mc, long long nargs,
                         DataStackEntry *args) {
    int i, n, ans, error;
    sqlinsert sqli;
    char *colval[NCOLUMNS];
    int *coltype[NCOLUMNS];
    char buf[2048];
    //  Logging, check that first argument is a valid topic ... 
    //  Build up colval and coltype, one entry per argument
        ... 
        ans = hwdb_insert(&sqli);
        // Error checking, freeing storage, etc
 }
```

`hwdb` is the "homework database", because "homework" was the project 
name (probably for the home router management project).  Files `hwdb.h`
and `hwdb.c` are the main (temporal) database managers.  (TBD: Read enough 
of hwdb.h and hwdb.c to understand requirements of the sql insertion). 

